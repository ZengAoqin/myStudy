# C语言基础

## 编译

### **gcc的编译过程**

gcc编译过程分为4个阶段：预处理、编译、汇编、链接。
预处理：头⽂件包含、宏替换、条件编译、删除注释
编译：主要进⾏词法、语法、语义分析等，检查⽆误后将预处理好的⽂件编译成汇编⽂件。
汇编：将汇编⽂件转换成 ⼆进制⽬标⽂件
链接：将项⽬中的各个⼆进制⽂件+所需的库+启动代码链接成可执⾏⽂件

### 静态库与动态库

静态库（Static Library）：

- 静态库是在编译时将库的代码和数据复制到可执行文件中，使得可执行文件独立于外部库文件。
- 在使用静态库时，链接器将库的代码和数据直接嵌入到最终的可执行文件中。
- 静态库的扩展名通常为`.a`（Unix/Linux）或`.lib`（Windows）。
- 静态库的优点是部署简单，程序运行时不需要依赖外部库文件。但是，如果多个可执行文件使用相同的静态库，会导致每个可执行文件中都包含一份库的副本，造成代码冗余。

动态库（Dynamic Library）：

- 动态库是在运行时由操作系统加载，可供多个可执行文件共享使用。
- 在使用动态库时，可执行文件只包含对库函数的引用，而不包含库的实际代码和数据。
- 动态库的扩展名通常为`.so`（Unix/Linux）或`.dll`（Windows）。
- 动态库的优点是节省内存，多个可执行文件可以共享同一份库的代码和数据。此外，如果动态库更新，不需要重新编译可执行文件，只需替换动态库文件即可。但是，运行时需要确保系统能够找到所需的动态库文件。

## 数据类型

- char	    存储大小1字节，值范围-128~127
- int 		  32、64位系统存储大小4字节，值范围-2147483648~2147483647
- float	    存储大小4字节 
- double    存储大小8字节
- 指针        32位存储大小4字节，64位存储大小8字节



## 数组

### 静态数组和动态数组

静态数组：类似int arr[5];在程序运⾏就确定了数组的⼤⼩，运⾏过程不能更改数组的⼤⼩。
动态数组：主要是在堆区申请的空间，数组的⼤⼩是在程序运⾏过程中确定，可以更改数组的⼤⼩。

### 数组的初始化数值

不初始化：如果是局部数组，数组元素的内容随机；如果是全局数组，数组的元素内容为0
部分初始化：未被初始化的部分⾃动补0
完全初始化：如果⼀个数组全部初始化，可以省略元素的个数，数组的⼤⼩由初始化的个数确定

### 数组名

数组名作为类型：代表的是整个数组的⼤⼩(sizeof)
数组名作为地址：代表的是数组⾸元素的地址
对数组名取地址：代表的是数组的⾸地址



## **变量分类**

- 普通局部变量： 存在栈区、不初始化内容随机、只在定义所在的复合语句中有效、符合语句结束变量空间释放

- 普通全局变量 ：存在全局区、不初始化内容为0、进程结束空间才被释放，能被当前源⽂件或其他源⽂件使⽤，只是其他源⽂件使⽤的时候，使⽤extern修饰
- 静态局部变量： 存在全局区、不初始化内容为0、整个进程结束空间才被释放，只能在定义所在的复合语句中有效
- 静态全局变量 ：存在全局区、不初始化内容为0、整个进程结束空间才被释放，只能被当前源⽂件使⽤



## 指针

### 空类型指针

void*是空类型指针，又叫万能指针，就是该指针能接收任意类型的指针，可以指向任何类型对象，所以不能对空类型指针进行解引用，必须强制类型转换成相应的指针类型，才能进行解引用操作。

### 空指针

空指针变量具有空指针值，表示它处于闲置状态，没有指向任何有意义的内容  int * ptr = NULL

### 野指针

野指针指向的位置是随机的、不可知的、不正确的。指针末初始化或指针释放后末置空

### 数组指针和指针数组

普通指针  指针指向数组首元素地址 写法：int arr[5]; int* p = arr;
数组指针  指针指向整个数组的地址 写法：int arr[5]; int(*p)[5] = &arr;
指针数组  定义保存指针类型的数组连续空间，类似于二维数组的存放 写法：char *p[5]; p[1] = "asd"; p[2] = "aff";

### 函数指针和指针函数

函数指针  使用指针指向函数的地址，函数名出现表达式中可以代表函数基地址 写法：int (*p)(int,int); p = add;
指针函数  返回值为指针类型的函数  写法：int\* func(int a,int b);

### 常量指针和指针常量

常量指针  const修饰指针本身，表示指针本身无法进行修改指向的地址  写法：char* const p;
指针常量  const修饰指针指向的目标，表示无法通过指针修改对应地址的数据  写法：const char* p;

### 函数指针数组

函数指针数组是每个元素都是函数指针的数组  写法：int (\*parr[10])(int,int);
parr先和[ ]结合，说明parr是数组，数组的内容是指向int (*)(int,int)类型的函数指针（函数本身的类型一定是参数为(int,int),返回值为(int)），函数指针的参数列表要和函数指针指向的函数的参数列表一致。



## 内存

### 内存分区

在C语言中，内存可以划分为堆区、栈区、全局区（静态区）、文字常量区和代码区。每个区域有不同的特点和用途。

- 堆区（Heap）：
  - 堆区用于动态分配内存，大小可在程序运行时进行调整。
  - 使用`malloc`、`calloc`、`realloc`等函数在堆区分配内存，并使用`free`函数释放内存。
  - 堆区的内存分配是离散的，没有固定的顺序和规则。
  - 堆区的内存需要手动管理，使用不当可能导致内存泄漏或内存溢出。
- 栈区（Stack）：
  - 栈区用于管理函数调用、局部变量和函数参数。
  - 栈区的内存分配由编译器自动完成，函数调用时分配内存，函数返回时释放内存。
  - 栈区的内存分配是连续的，以后进先出（LIFO）的方式进行操作。
  - 栈区的大小有限，通常较小，由编译器在程序编译时确定。
- 全局区（静态区）：
  - 全局区用于存储全局变量和静态变量。
  - 全局变量在程序启动时分配内存，在程序结束时释放内存。
  - 静态变量在程序执行期间一直存在，不会随函数的调用和返回而分配和释放内存。
  - 全局区的内存分配是连续的，其大小由全局变量和静态变量的总大小决定。
- 文字常量区（Literal Area）：
  - 文字常量区存储字符串常量和其他常量数据。
  - 字符串常量通常是在程序编译时就确定并存储在该区域，例如`"Hello, World!"`。
  - 文字常量区的内存通常是只读的，不允许修改。
- 代码区（Code Area）：
  - 代码区存储程序的可执行指令。
  - 程序的二进制代码在编译后存储在代码区，供计算机执行。
  - 代码区的内存通常是只读的，不允许修改。

### 内存的申请和释放

- malloc  在堆中开辟空间 如int* p=(int*)malloc(20);

- calloc    返回地址之前把申请的空间的每个字节初始化为全0 如int* p = (int*)calloc(NUM, sizeof(int));

- realloc  调整动态开辟的内存 如int* ptr = (int*)realloc(p, 40);

- free	  用来释放和回收动态内存，规避内存泄露


### 内存泄漏

内存泄漏是指程序在运行过程中由于错误或疏忽未能释放不再需要的内存，导致系统内存耗尽。当程序中的内存泄漏累积到一定程度时，可能导致程序性能下降甚至崩溃。使用 malloc()、calloc()、realloc() 动态分配的内存，如果没有指针指向它，就无法进行任何操作，这段内存会一直被程序占用，直到程序运行结束由操作系统回收。



## 文件IO

### 系统IO和标准IO

- 系统IO是Linux系统调用（内核API），而标准IO是C语言库函数；
- 系统IO不带缓冲，标准IO带有缓冲
- 系统IO操作的是文件描述符，标准IO操作的是流FILE
- 系统IO和标准IO所使用的的函数不同

### 文件描述符

文件描述符（File Descriptor）是操作系统中用于标识打开文件或其他I/O资源的整数值。文件描述符是一种抽象概念，它提供了对底层文件或I/O资源的访问。
文件描述符在使用时遵循以下原则：

- 文件描述符的获取：文件描述符可以通过打开文件或创建新的I/O资源时由操作系统分配获得。通常使用类似于`open`、`socket`等系统调用来获取文件描述符。
- 文件描述符的使用范围：文件描述符在进程的上下文中是唯一且有效的。不同进程的文件描述符可以相同，但在同一个进程中，每个打开的文件描述符都是唯一的。
- 文件描述符的传递：文件描述符可以通过进程间的通信机制（如管道、套接字等）在不同进程之间传递。这样，一个进程可以将打开的文件描述符传递给另一个进程，以实现文件共享或进行I/O操作。
- 文件描述符的关闭：在不再需要某个文件描述符时，应该及时将其关闭。关闭文件描述符可以通过调用`close`系统调用或相关的库函数来完成。关闭文件描述符会释放操作系统资源，并确保不再使用该文件描述符。

文件描述符的最大值取决于操作系统和文件系统的限制。在大多数Unix和类Unix系统中，文件描述符是非负整数，通常从0开始分配。最大文件描述符的值可以通过查询操作系统的相关限制来获得。在Linux系统中，可以通过`ulimit`命令或查询`RLIMIT_NOFILE`限制来获取最大文件描述符数。

### 标准IO的流

在标准输入输出（Standard I/O）中，流是一种抽象概念，用于描述程序与输入输出设备之间的交互。标准I/O流是指与标准输入（stdin）、标准输出（stdout）和标准错误（stderr）相关联的流。

- 标准输入流（stdin）用于接收输入数据，通常是用户从键盘输入的数据。程序可以从stdin流中读取数据，以便进行处理。
- 标准输出流（stdout）用于输出数据，通常是程序输出到屏幕上的数据。程序可以向stdout流写入数据，以便显示给用户。
- 标准错误流（stderr）用于输出错误信息，通常是程序在发生错误或异常情况时输出的信息。

### 阻塞IO和非阻塞IO

阻塞I/O：

- 在阻塞I/O模型中，当应用程序发起一个I/O操作（如读取或写入），它会等待该操作完成后再继续执行后续代码。
- 在进行阻塞I/O操作时，应用程序的执行被阻塞，直到I/O操作完成或达到超时时间。
- 阻塞I/O是一种同步的I/O模型，它会导致应用程序被阻塞在I/O操作上，无法进行其他任务。

非阻塞I/O：

- 在非阻塞I/O模型中，当应用程序发起一个I/O操作，如果操作可以立即完成，应用程序可以继续执行后续代码；如操作无法立即完成，程序会立即返回，应用程序会得到一个错误码或指示操作仍在进行中的状态，而不会等待该操作完成。
- 非阻塞I/O是一种异步的I/O模型，它允许应用程序在进行I/O操作的同时执行其他任务。

### IO多路复用

I/O多路复用（I/O Multiplexing）是一种用于实现高效的事件驱动I/O操作的技术。它允许单个线程同时监视多个I/O事件，从而避免了使用多线程或多进程来处理并发I/O操作的需要。
传统的阻塞I/O模型中，每个I/O操作都会导致线程或进程阻塞，直到该操作完成。这种模型在同时处理多个I/O操作时效率较低，因为每个I/O操作都需要一个独立的线程或进程。而使用I/O多路复用，可以通过一个阻塞的系统调用同时监视多个I/O事件，如读取数据、接受连接、发送数据等。常见的I/O多路复用机制包括select、poll和epoll。

### 多路复用之select、poll和epoll模型

select：

- select是最早出现的多路复用机制之一，可用于同时监视多个文件描述符是否有I/O事件发生。
- 在使用select时，需要创建并维护一个用于存放待监视文件描述符的数据结构，然后通过调用select函数来阻塞等待其中任何一个文件描述符上的事件发生。
- select函数会返回哪些文件描述符上有事件发生，然后应用程序可以遍历返回的结果进行相应的处理。
- select的一个限制是它使用的文件描述符集合有大小限制，通常是1024个。

poll：

- poll是对select的改进，也可用于同时监视多个文件描述符上的I/O事件。
- 与select不同，使用poll时无需创建和维护文件描述符集合，而是通过一个pollfd结构数组来表示待监视的文件描述符和事件。
- 调用poll函数时，它会阻塞等待任何一个文件描述符上的事件发生，并返回发生事件的文件描述符及其对应的事件类型。
- 它没有最大连接数的限制，原因是它是基于链表来存储的。

epoll：

- epoll是在Linux系统上引入的高性能多路复用机制，相对于select和poll有更好的扩展性和性能。
- epoll使用了事件驱动的方式，通过将文件描述符添加到内核管理的事件表中，当有事件发生时，内核会通知应用程序。
- epoll提供了三种I/O事件触发模式：边缘触发（EPOLLET）、水平触发（默认）和一次性触发（EPOLLONESHOT）。
- 边缘触发模式在事件发生时只通知一次，需要应用程序处理完整个事件；水平触发模式会在事件发生时持续通知，直到应用程序处理完事件。

### epoll之水平触发和边沿触发

水平触发（EPOLLLT）：

- 在水平触发模式下，当文件描述符上有可读或可写事件发生时，内核会持续通知应用程序。水平触发是epoll默认的工作模式。
- 如果应用程序没有立即处理事件，内核会继续通知该文件描述符上的事件，直到应用程序处理完事件或者应用程序停止监听该文件描述符。
- 水平触发适用于需要持续监视文件描述符上的事件的情况，即使应用程序没有立即处理事件。
-  缺点：当数据较大时，需要不断从用户态和内核态切换，消耗了大量的系统资源，影响服务器性能；

边沿触发（EPOLLET） ：

- 在边沿触发模式下，当文件描述符上有可读或可写事件发生时，内核只会通知应用程序一次。
- 不管应用程序是否立即处理事件，内核只会在事件发生时发送一次通知。如果应用程序没有及时处理事件，将不会再次收到通知，直到有新的事件发生。
- 边沿触发适用于需要及时响应文件描述符上的事件，且只关心事件是否发生的情况。
- 使用边沿触发模式时，应用程序需要确保尽快处理事件，并通过非阻塞方式读取或写入尽可能多的数据，以免错过事件。





# 数据结构

## 数据结构的相关概念

数据结构：指互相之间存在着一种或多种特定关系的数据元素的集合。包括逻辑结构，存储结构和对数据的运算。常用的数据结构有：数组（Array）、栈（Stack）、队列（Queue）、链表（Linked List）、树（Tree）、图（Graph）、堆（Heap）、散列表（Hash）等；

数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。

数据元素：数据的基本单位，一个数据元素可由若干数据项组成。

数据项：数据的不可分割的最小单位。

数据对象：性质相同的数据元素的集合，是数据的一个子集。

逻辑结构：是指数据之间关系的描述，与数据的存储结构无关。分为线性结构和非线性结构，通常分为四类结构：

- 集合：结构中的数据元素除了同属于一种类型外，别无其它关系。
- 线性结构：结构中的数据元素之间存在一对一的关系。
- 树型结构：结构中的数据元素之间存在一对多的关系。
- 图状结构（网状结构）：结构中的数据元素之间存在多对多的关系。

存储结构：是指数据结构在计算机中的表示，又称为数据的物理结构。它包括数据元素的表示和关系的表示，通常由四种基本的存储方法实现：

- 顺序存储方式：数据元素顺序存放，每个存储结点只含一个元素。存储位置反映数据元素间的逻辑关系。存储密度大。但有些操作（插入、删除）效率较差。
- 链式存储方式：每个存储结点除包含数据元素信息外还包含一组（至少一个）指针。指针反映数据元素间的逻辑关系。这种方式不要求存储空间连续，便于动态操作（如插入、删除等），但存储空间开销大（用于指针），另外不能折半查找等。
- 索引存储方式：除数据元素存储在一组地址连续的内存空间外，还需建立一个索引表，索引表中索引指示存储结点的存储位置（下标）或存储区间端点（下标）。
- 散列存储方式：通过散列函数和解决冲突的方法，将关键字散列在连续的有限的地址空间内，并将散列函数的值解释成关键字所在元素的存储地址。其特点是存取速度快，只能按关键字随机存取，不能顺序存取，也不能折半存取。

算法：是对特定问题求解步骤的一种描述，是指令的有限序列。其中每一条指令表示一个或多个操作。算法和程序十分相似，但又有区别。程序不一定具有有穷性，程序中的指令必须是机器可执行的，而算法中的指令则无此限制。算法代表了对问题的解，而程序则是算法在计算机上的特定的实现。一个算法若用程序设计语言来描述，则它就是一个程序。

算法的特性：有穷性，确定性，可行性，输入，输出。

算法的设计目标：正确性，可读性，健壮性，高效率与低存储量需求

算法的时间复杂度：以基本运算的原操作重复执行的次数作为算法的时间度量。一般情况下，算法中基本运算次数T(n)是问题规模n（输入量的多少，称之为问题规模）的某个函数f(n)，记作：T(n)＝Ο(f(n))



## 线性表

线性表：具有相同特性数据元素的一个有限序列，该序列中所含元素的个数叫做线性表的长度。线性结构包括：线性表、栈、队列、串。
线性表的存储结构分为：顺序存储结构和链式存储结构。

###  顺序表

顺序表：把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里。
顺序表的特点：1.随机访问特性 2.占有连续的存储空间 2.做插入操作时要移动多个元素
缺点： 大小固定，不容易修改，内存是连续不断的，若内存不足则无法操作

```c
//顺序表元素存储格式
struct Data
{
	int arr[MAX];		//数据域
	int count;		    //下标域
};
```

### 链表

链表：一种物理储存单元上非连续，非顺序的存储结构。
链表的特点：1.不支持随机访问 2.结点的存储空间利用率较低 3.支持存储空间的动态分布 4.做插入操作时不需要移动元素

```c
//单链表元素存储格式
struct list
{
	int data;			    //数据域
	struct list *next;		//指针
};
```

### 栈

栈：是一种只能在一端（表尾）进行插入或删除操作的线性表。允许进行插入或删除的一端成为栈顶（TOP），表的另一端成为栈底（栈底固定不变）。可用顺序表和链表来存储栈，可分为顺序栈和链栈。
主要特点：先进后出（FILO）

### 队列

队列：是一种仅允许在表的一端（队尾rear）进行插入，在表的另一端（队头Front）进行删除的线性表。可用顺序表和链表来存储队列，可分为顺序队列和链队。
主要特点：先进先出（FIFO）



## 树

### 树的相关概念

树：树是由*n(n≥0*)个有限节点组成一个具有层次关系的集合

结点的度：结点拥有的子树的个数或者分支的个数。

树的度：树中各节点度的最大值。

树的高度（深度）：树中结点的最大层次。

叶子结点（终端节点）：指度为0的结点。

分支结点（非终端节点）：指度不为0的结点；除了根节点之外的非终端结点称为内部节点。

结点的关系：

- 孩子：结点的子树的根。
- 双亲：B结点是A结点的孩子；则A结点是B结点的双亲。
- 兄弟：同一个双亲的孩子之间互为孩子。
- 祖先：从根节点到某结点的路径上的所有结点
- 子孙：以某结点为根的子树中的所有结点。
- 堂兄弟：双亲在同一层的结点互为堂兄弟。

有序树：树中结点的子树从左到右是有次序的，不能互换

无序树：树中结点的子树没有顺序，可以任意互换

森林：若干棵互不相交的树的集合。

树的存储结构：树的顺序存储结构为双亲表示法（每个结点中只保存了指示哪个结点是它的双亲结点的信息）；树的链式存储为孩子表示法或孩子兄弟表示法。

### 二叉树

二叉树：（1）每个结点最多只有两棵子树，即二叉树中结点的度只能是0,1,2。（2）子树有左右顺序之分，不能颠倒。

满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。如果一个满二叉树的层数为K，则结点总数是(2^k) -1 。

完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边。

二叉树的遍历：前序遍历、中序遍历、后序遍历和层次遍历。

- 前序遍历是指先访问根节点，然后依次递归访问左子树和右子树；
- 中序遍历是指先递归访问左子树，然后访问根节点，最后递归访问右子树；
- 后序遍历是指先递归访问左子树和右子树，最后访问根节点。
- 层次遍历是指从二叉树的第一层（根节点）开始，从上至下逐层遍历，在同一层中，则按照从左到右的顺序对节点逐个访问。在逐层遍历过程中，按从顶层到底层的次序访问树中元素，在同一层中，从左到右进行访问。

### 霍夫曼树

霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为WPL=（W1L1+W2L2+W3L3+…+WnLn），N个权值Wi（i=1,2,…n）构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li（i=1,2,…n）。可以证明赫夫曼树的WPL是最小的。哈夫曼树的特点：

1.权值越大的结点，距离根结点越近。
2.树中没有度为1的结点，这类树又叫做正规（严格）二叉树。
3.树的带权路径长度最短。

路径：指从树中一个结点到另一个结点的分支所构成的路线。

路径长度：指路径上的分支数目。

树的路径长度：指根到每个结点的路径长度之和

节点的权： 给树的每个结点赋予一个具有某种实际意义的实数，我们称该实数为这个结点的权。

带权路径长度：结点具有权值，从该结点到根之间的路径长度乘以结点的权值为该结点的带权路径长度。

树的带权路径长度（WPL）：指树中所有叶子结点的带权路径长度之和。



## 图



## 常见排序算法

- 冒泡排序	每次排序，比较相邻位置元素 交换位置
- 选择排序	每次排序，在未排序序列中找到最（小/大）元素，与未排序集合（末尾/起始）元素交换位置
- 插入排序	每次排序，将未排序集合中第一个数值取出，插入到已排序集合的相应的位置
- 快速排序	任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。

## 排序算法复杂度对比

![](./img/排序.png)





# 系统编程

## 进程

进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位，是操作系统结构的基础。

### 进程的状态

进程一共有`5`种状态，分别是创建、就绪、运行（执行）、阻塞、终止。

运行状态就是进程正在CPU上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。
就绪状态就是说进程已处于准备运行的状态，即进程获得了除CPU之外的一切所需资源，一旦得到CPU即可运行。
阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待I/O完成。即使CPU空闲，该进程也不能运行。

运行态→阻塞态：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。
阻塞态→就绪态：则是等待的条件已满足，只需分配到处理器后就能运行。
运行态→就绪态：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，更高优先级的进程来抢占处理器。
就绪态→运行态：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。

### 进程相关函数

pid_t fork(void) //创建子进程（返回==0：创建的子进程对象 返回为>0: 当前子进程的父进程 返回为-1：创建子进程失败）
pid_t vfork(void) //创建子进程和阻塞父进程，vfork创建的子进程是优先父进程执行
pid_t getpid(void); //获取当前进程的id号
pid_t getppid(void);  //获取当前进程的父进程的ID号
void exit(int status);  //清空缓冲区，然后再退出,激活父进程
pid_t wait(int *status);  //监听子进程退出时候的状态 （返回：成功：退出的子进程的PID号 失败：返回-1）
pid_t waitpid(pid_t pid, int *status, int options);	

### 子进程写时拷贝

写时拷贝（Copy-on-Write，COW）是一种在创建子进程时用于减少内存复制开销的技术。它通过延迟对共享内存的复制，只有在需要修改内存时才进行实际的复制操作。
当父进程创建子进程时，操作系统会将父进程的内存空间完全复制到子进程的地址空间中。在传统的内存复制方式中，这个过程会消耗大量的时间和内存资源，尤其是当父进程的内存空间较大时。而使用写时拷贝技术时，父进程和子进程会共享相同的物理内存页。当父进程或子进程试图修改这些共享的内存页时，才会触发实际的内存复制操作。这样可以避免不必要的内存复制，减少了时间和内存开销。

### 僵尸进程、孤儿进程、守护进程

- 僵尸进程：如果子进程先退出，系统不会自动清理掉子进程的环境，而必须由父进程调用wait或waitpid函数来完成清理工作，如果父进程不做清理工作，则已经退出的子进程将成为僵尸进程，占用cpu资源
- 孤儿进程：当父子进程存在的时候，父进程提前退出，系统会指定祖宗进程为父进程，等待子进程执行完成，回收子进程的资源。
- 守护进程：又叫精灵进程和后台进程，守护进程只能通过kill命令发送杀死信号或者直接关闭系统可以销毁精灵进程，剩下的方式不会让精灵进程死亡，从操作系统启动的时候就开始创建，在操作系统关闭的时候结束对应的进程，他们不受其他的信号的管理，文件或者数据流的影响，一般用于记录当前系统的运行状态。精灵进程是运行在后台的一种特殊的进程，它独立于控制终端并且周期性的执行某种任务或者等待处理某些发生事件，不依赖用户输入就能提供某种服务。

### 进程间通讯方式

- 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 
- 有名管道（FIFO）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 
- 消息队列（MessageQueue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 
- 共享内存（SharedMemory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。 
- 信号量（Semaphore）：信号量适用于多进程或者多线程之间的数据协调，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- 套接字（Socket）：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 
- 信号 (singal) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。



## 线程

线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。

### 线程相关函数

int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); //创建一个新线程
pthread_t pthread_self(void); //获取线程的id号
void pthread_exit(void *retval);  //结束一个线程
int pthread_join(pthread_t thread, void **retval);  //收回结束的线程资源

### 线程分离

线程分离就是当线程被设置为分离状态后，线程结束时，它的资源会被系统自动的回收，而不再需要在其它线程中对其进行 pthread_join() 操作。
在我们使用默认属性创建一个线程的时候，线程是 joinable (即主线程和子线程时结合的)的。 joinable 状态的线程，必须在另一个线程中使用 pthread_join() 等待其结束，如果一个 joinable 的线程在结束后，没有使用 pthread_join() 进行操作，这个线程就会变成”僵尸线程”。每个僵尸线程都会消耗一些系统资源，当有太多的僵尸线程的时候，可能会导致创建线程失败。

### 线程安全

线程安全是多个线程并发同一段代码时，不会出现不同的结果，我们就可以说该线程是安全的；
线程安全产生的原因：大多是因为对全局变量和静态变量的操作
如何实现：使用锁机制，原子操作，信号量

### 信号量

信号量（Semaphore）是一种经典的线程同步机制，用于控制对共享资源的访问数量。它基于一个计数器和两个原子操作（P操作和V操作）。

1. P操作（等待操作）：
   - 当线程需要访问共享资源时，首先执行P操作。
   - P操作会检查信号量的计数器。如果计数器大于0，则线程可以继续执行，并将计数器减1。
   - 如果计数器为0，则线程被阻塞，进入等待状态，直到有其他线程执行V操作增加计数器的值。
2. V操作（释放操作）：
   - 当线程使用完共享资源后，执行V操作来释放资源。
   - V操作会将信号量的计数器加1。
   - 如果有其他线程正在等待该信号量，其中一个等待的线程将被唤醒，并可以继续执行。

信号量的原理可以简单总结为：当计数器大于0时，线程可以继续执行，计数器减1。当计数器为0时，线程被阻塞，等待其他线程执行V操作唤醒它。

### 锁机制

- 互斥锁提供了以排他方式防止数据结构被并发修改的方法。 
- 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。 
- 自旋锁让线程一直等待并不停的进行锁请求，直到得到这个锁为止。自旋锁的作用是为了解决某项资源的互斥使用。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。因此如果锁的内容较少，阻塞的时间较短，使用自旋锁比较好。
- 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

```cpp
// 读写锁举例
#include <stdio.h>
#include <pthread.h>

#define DATA_SIZE 100

int data[DATA_SIZE];  // 共享数据
pthread_rwlock_t rwlock;  // 读写锁

void* reader(void* arg) {
    int thread_id = *(int*)arg;

    while (1) {
        // 获取读锁
        pthread_rwlock_rdlock(&rwlock);

        // 读取共享数据
        printf("Reader %d read data: ", thread_id);
        for (int i = 0; i < DATA_SIZE; i++) {
            printf("%d ", data[i]);
        }
        printf("\n");

        // 释放读锁
        pthread_rwlock_unlock(&rwlock);

        // 延时一段时间
        usleep(100000);
    }

    return NULL;
}

void* writer(void* arg) {
    int thread_id = *(int*)arg;

    while (1) {
        // 获取写锁
        pthread_rwlock_wrlock(&rwlock);

        // 更新共享数据
        for (int i = 0; i < DATA_SIZE; i++) {
            data[i] = thread_id;
        }
        printf("Writer %d wrote data\n", thread_id);

        // 释放写锁
        pthread_rwlock_unlock(&rwlock);

        // 延时一段时间
        usleep(200000);
    }

    return NULL;
}

int main() {
    pthread_t readers[3];
    pthread_t writers[2];
    int reader_ids[3] = {1, 2, 3};
    int writer_ids[2] = {1, 2};

    // 初始化读写锁
    pthread_rwlock_init(&rwlock, NULL);

    // 创建读者线程
    for (int i = 0; i < 3; i++) {
        pthread_create(&readers[i], NULL, reader, &reader_ids[i]);
    }

    // 创建写者线程
    for (int i = 0; i < 2; i++) {
        pthread_create(&writers[i], NULL, writer, &writer_ids[i]);
    }

    // 等待读者线程结束
    for (int i = 0; i < 3; i++) {
        pthread_join(readers[i], NULL);
    }

    // 等待写者线程结束
    for (int i = 0; i < 2; i++) {
        pthread_join(writers[i], NULL);
    }

    // 销毁读写锁
    pthread_rwlock_destroy(&rwlock);

    return 0;
}
```



### 死锁

死锁是指多个进程或线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。

死锁产生的原因 

1. 系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。 
2. 进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。

死锁的必要条件：

1. 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 
2. 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 
3. 不可剥夺条件: 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。 
4. 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系

避免死锁的方式

1. 避免循环等待：确保线程或进程在请求资源时不会形成循环等待。可以通过定义资源请求的顺序来避免循环等待，例如按照资源的编号或者按照固定的顺序获取资源。
2. 使用超时机制：在获取资源时，使用超时机制来避免无限等待资源的情况。如果等待超过一定的时间仍未获取到资源，可以放弃当前的申请或者进行其他处理。
3. 避免持有多个资源：尽量避免线程或进程同时持有多个资源。如果需要同时持有多个资源，可以使用资源分级和顺序获取的方式，减少死锁的可能性。
4. 避免死锁：使用资源分配和调度算法，避免资源分配的情况下形成死锁。例如，银行家算法（Banker's algorithm）可以用于避免死锁发生，通过动态分配资源来满足进程的请求，保证系统不会陷入死锁状态。

解决死锁问题：

1. 检测和恢复死锁：实现死锁检测算法，及时发现死锁的存在。一旦检测到死锁，可以采取相应的恢复措施来打破死锁状态。常见的死锁恢复方法包括终止某些线程或进程、回滚操作、释放资源等。
2. 强制解除死锁：在某些情况下，如果死锁发生的概率非常低，或者死锁的代价非常高，可以采取强制解除死锁的策略。这涉及到终止所有死锁的线程或进程，并释放它们占用的资源，从而解除死锁状态。

### 进程和线程对比

- 定义的区别：
  进程：具有一个独立功能的程序，拥有独立的内存空间
  线程： 它是比进程更小的能独立运行的基本单位，线程本身是不拥有系统资源的，它和属于同一个进程的其他线程共享进程中所有资源内容。
- 调用区别：
  进程：拥有资源(管理资源、分配资源)的基本单位
  线程：调用和分派任务的基本的单位
- 共享地址空间：
  进程：拥有各自独立的地址空间、资源, 所以共享复杂,需要使用IPC（进程间通信）,但是同步简单
  线程：共享所属进程的资源，因此共享简单，但是同步复杂，需要用锁特性加持
- 占用内存和cpu
  进程：占用内存多，切换复杂，cpu利用率较低
  线程：占用内存少，切换简单，cpu利用率较高
- 互相影响
  进程：进程之间不会相互影响，内存地址独立
  线程：一个线程无故挂掉，可能导致整个进程挂掉





# 网络编程

## OSI模型和TCP/IP协议

OSI网络模型有七层模型：分别是应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。
目前广泛使用的是 TCP/IP协议族网络四层模型：从上往下依次是应用层、传输层、网际层和网络接口层。

## TCP与UDP传输层通信协议

- TCP是面向连接的，UDP是无连接的 
- TCP是可靠的，UDP是不可靠的 
- TCP是面向字节流的，UDP是面向数据报文的
-  TCP只支持点对点通信，UDP支持一对一，一对多，多对多 
- TCP有拥塞控制机制，UDP没有 
- TCP协议下双方发送接受缓冲区都有，UDP并无实际意义上的发送缓冲区，但是存在接受缓冲区

## TCP三次握手和四次挥手  

三次握手： 

1. 客户端发起连接，发送一个SYN报文给服务端，然后说明自己连接的端口和客户端初始序列号 seq1。  
2. 服务端收到SYN报文，也需要发起反方向的连接，所以发送一个SYN报文给服务端，说明自己连接的端口和服务端初始序列号seq2，除此以外，这个报文还可以携带一个确认信息，所以把seq1+1 作为ACK返回。 
3. 客户端收到服务端的SYN之后，需要确认，所以把seq2+1作为ACK返回给服务端。 

四次挥手： 

1. 主动关闭方发送一个FIN段表示希望断开连接。  
2. 被动关闭方收到FIN段，并且回复一个确认信息。其上层应用会收到一个EOF，被动关闭方继续传输剩余的数据。 
3. 被动关闭方发送完数据了，发送一个FIN段。   
4. 主动关闭方回复一个确认，并且等待一段时间（2MSL，MSL指单个报文在网络中的最长生存时间）。

## TCP 网络编程流程

```c
//服务端
//1.建立TCP连接，创建Socket文件描述符fd(sockfd)，即建立通信端点 socket
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
if(-1 == sockfd)
{
    fprintf(stderr, "line[%d] socket failed\n", __LINE__);
    return -1;
}
else
{
    printf("成功申请套接字为：%d\n", sockfd);
}

//2.绑定套接字文件描述符sockfd与网络地址和端口号，即ip地址+端口号 bind
//初始化IP地址和端口的结构体
struct sockaddr_in ServerAddr; 	//定义结构体对象
memset(&ServerAddr, 0, sizeof(ServerAddr)); //清空操作
ServerAddr.sin_family = AF_INET; //协议族
ServerAddr.sin_port = htons(atoi(argv[1])); //设置端口号
ServerAddr.sin_addr.s_addr = htonl(INADDR_ANY); //接收任意的IP地址
int ret = bind(sockfd, (struct sockaddr *)&ServerAddr, sizeof(ServerAddr));
if(-1 == ret)
{
    fprintf(stderr, "line[%d] bind failed\n", __LINE__);
    return -1;
}

//3.设置套接字进入被动监听状态，即设置套接字的监听 listen
listen(sockfd, 1);

//4.等待客户端连接服务器，发起连接请求 accept
struct sockaddr_in ClientAddr; 	//定义结构体对象
memset(&ClientAddr, 0, sizeof(ClientAddr)); //清空操作

socklen_t len = sizeof(ClientAddr);
int confd = accept(sockfd, (struct sockaddr *)&ClientAddr, &len);
if(-1 == confd)
{
    fprintf(stderr, "line[%d] accept failed\n", __LINE__);
    return -1;
}
printf("连接成功的套接字%d\n", confd);

//5.收到连接请求，获取客户端的连接套接字confd，用于数据的接收和发送 recv/send
char buf[128];
for(;;)
{
    memset(buf, 0, sizeof(buf)); //清空buf
    read(confd, buf, sizeof(buf)); //接收连接成功套接字的数据
    printf("[%s]客户端发送的内容为:%s", inet_ntoa(ClientAddr.sin_addr), buf);

    if(!strcmp(buf, "byebye\n"))
        break;
}

//6.关闭服务端对象 close
close(sockfd);


//客户端
//1.建立TCP套接字，创建sockfd，即建立通信端点 Socket
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
if(-1 == sockfd)
{
    fprintf(stderr, "line[%d] socket failed\n", __LINE__);
    return -1;
}
else
{
    printf("成功申请套接字为：%d\n", sockfd);
}

//2.对服务端发送请求connect，同步配置ip地址和端口
struct sockaddr_in ServerAddr;
memset(&ServerAddr, 0, sizeof(ServerAddr));
ServerAddr.sin_family = AF_INET; //协议族
ServerAddr.sin_port = htons(atoi(argv[2])); //设置端口号
ServerAddr.sin_addr.s_addr = inet_addr(argv[1]); //IPV4的地址
//启动连接服务器
connect(sockfd, (struct sockaddr *)&ServerAddr, sizeof(ServerAddr));

//3.请求连接成功，通过套接字sockfd进行数据的接收和发送 recv/send
char buf[128];
for(;;)
{
    memset(buf, 0, sizeof(buf)); //清空数组
    printf("请输入发送的内容\n");
    fgets(buf, sizeof(buf), stdin);
    write(sockfd, buf, strlen(buf)); //发送消息给Server
    if(!strcmp(buf, "byebye\n"))
    {
        break;
    }
}

//4.关闭客户端对象 close
close(sockfd);
```





# C++ 基础

## C++ 特性

### 命名空间

C++中的命名空间（Namespace）是一种用于避免命名冲突和组织代码的机制。命名空间可以将相关的变量、函数、类等实体封装在一个逻辑上的作用域内，以便在程序中进行引用和访问。



### 内联函数和宏定义

内联函数：

- 内联函数是一种函数定义的方式，在函数调用处直接将函数体插入，而不是通过函数调用的方式执行。
- 内联函数通常是通过在函数定义前加上`inline`关键字来声明的。
- 内联函数的目的是为了减少函数调用的开销，提高程序的执行效率。
- 内联函数在编译时展开，因此可以避免函数调用的开销，但会增加代码的大小。
- 内联函数适用于函数体较小且频繁调用的情况。

宏定义：

- 宏定义是一种文本替换的机制，使用预处理器（Preprocessor）将宏定义的标识符替换为相应的文本。
- 宏定义使用`#define`指令来定义，可以定义常量、函数或复杂的代码片段。
- 宏定义是简单的文本替换，没有函数的调用开销，但也没有类型检查等编译时的安全性保证。
- 宏定义在预处理阶段就完成了替换，不会增加代码的大小。
- 宏定义适用于需要进行简单的文本替换的场景。



### 引用和指针

引用：

- 引用是一个已存在对象的别名，用于直接访问该对象。
- 引用必须在定义时进行初始化，并且一旦初始化后，它将一直引用同一个对象，无法改变引用的目标。
- 引用使用的语法是在变量名前加上`&`符号进行声明，并且在使用时无需使用`*`符号进行解引用。
- 引用可以被看作是对象的一个别名，对引用的操作就是对目标对象的操作。

指针：

- 指针是一个变量，存储了一个对象的内存地址。
- 指针可以指向任何类型的对象，包括基本类型、自定义类型、函数等。
- 指针使用的语法是在变量名前加上`*`符号进行声明，并且在使用时需要使用`*`符号进行解引用，以访问指针指向的对象。
- 指针可以改变指向的对象，即可以修改指针的值来指向不同的对象。

引用和指针之间的区别：

- 引用必须在定义时进行初始化，而指针可以先声明，后赋值。
- 引用一旦初始化后，无法改变引用的目标，而指针可以通过修改指针的值来指向不同的对象。
- 引用不存在空引用的概念，必须引用一个已存在的对象，而指针可以为空指针（nullptr）。
- 引用不需要使用解引用符号就可以访问对象，而指针需要使用解引用符号。
- 引用没有自己的内存地址，而指针有自己的内存地址。

在使用引用和指针时，需要根据具体的需求和情况来选择合适的方式。引用通常用于函数参数传递、返回值、遍历容器等场景，而指针则更灵活，可以动态地分配和释放内存，处理数组和复杂的数据结构等。

### new、delete和malloc、free

- `new`和`delete`是C++关键字，而`malloc`和`free`是C语言函数。
- `new`和`delete`会调用对象的构造函数和析构函数来进行初始化和清理，而`malloc`和`free`不会。
- `new`和`delete`可以用于动态分配单个对象和数组，而`malloc`和`free`只能用于动态分配指定字节数的内存。
- `malloc`返回的是`void*`类型的指针，需要进行类型转换，而`new`返回的是指定类型的指针。
- `new`和`delete`在内存分配失败时会抛出异常（C++异常处理机制），而`malloc`在分配失败时返回`NULL`。



## C++ 面向对象

### 面向对象的特性

- 封装（Encapsulation）: 封装是将数据和操作数据的方法封装在类中的机制。通过使用访问修饰符（如公有、私有和保护）来限制对类的成员的访问，实现了封装的概念。封装提供了数据隐藏和信息隐藏的特性。
- 继承（Inheritance）: 继承是一种通过建立类之间的关系来实现代码重用和扩展的机制。子类（派生类）可以继承父类（基类）的属性和方法，并可以添加自己的特定属性和方法。继承支持单继承和多继承。
- 多态（Polymorphism）: 多态是一种允许使用相同的接口来处理不同的对象类型的能力。通过多态，可以在运行时根据对象的实际类型来调用适当的方法，实现了多态性。多态性提供了代码的灵活性和可扩展性。

### 类和对象

类是面向对象编程的基本构建单元，它封装了数据和操作数据的方法。类定义了对象的属性和行为，并定义了对象的初始状态和操作。
对象是类的实例，通过创建类的对象来使用类的属性和方法。对象具有类定义的属性和行为，并可以通过方法调用来操作数据。

### 类的继承

继承：允许一个类（称为派生类或子类）继承另一个类（称为基类或父类）的属性和行为。通过继承，派生类可以重用基类的代码，并在此基础上添加新的成员变量和成员函数，或者修改继承的成员。
派生：在已有类的基础之上新增自己的特性，从而产生新类的过程称为派生
父类：被继承的类称为父类或者基类
子类：派生出来的新类称为子类或者派生类

| 父类的权限/继承方式 | public         | protected      | private      |
| ------------------- | -------------- | -------------- | ------------ |
| public              | 可用/public    | 可用/protected | 可用/private |
| protected           | 可用/protected | 可用/protected | 可用/private |
| private             | 不可用         | 不可用         | 不可用       |

虚继承：

虚继承是一种在多继承中解决菱形继承问题的机制，它可以用于构建继承关系中的虚基类。虚继承用于解决通过不同路径继承同一个基类时可能导致的二义性和冗余数据的问题。

在虚继承中，通过在继承关系中的某个基类声明前加上 `virtual` 关键字，将该基类标记为虚基类。虚基类的子类只会继承一个共享的虚基类子对象，而不是多次复制。

```cpp
#include <iostream>

class Animal {
public:
    int age;
};

class Mammal : virtual public Animal {
public:
    void eat() {
        std::cout << "Mammal eats." << std::endl;
    }
};

class WingedAnimal : virtual public Animal {
public:
    void fly() {
        std::cout << "Winged animal flies." << std::endl;
    }
};

class Bat : public Mammal, public WingedAnimal {
public:
    void sleep() {
        std::cout << "Bat sleeps during the day." << std::endl;
    }
};

int main() {
    Bat bat;
    bat.age = 5; // 访问虚基类 Animal 的成员

    std::cout << "Bat's age: " << bat.age << std::endl;
    bat.eat();
    bat.fly();
    bat.sleep();

    return 0;
}
```

### 友元函数和友元类

友元函数：

- 友元函数是在一个类中声明的非成员函数，但被该类声明为友元。这意味着友元函数可以直接访问该类的私有成员。
- 友元函数的声明通常写在类的内部，但定义需要在类的外部进行。
- 友元函数的访问权限不受类的访问修饰符（public、private、protected）的限制。

友元类：

- 友元类是在一个类中声明的另一个类，被该类声明为友元。这意味着友元类的成员函数可以直接访问该类的私有成员。
- 友元类的声明通常写在类的内部，可以在类的任何位置进行声明。被声明为友元的类通常在之后进行定义。
- 友元类的访问权限不受类的访问修饰符的限制。

### 函数的重载和重写

函数重载（Overloading）：

- 重载是指在同一个作用域内，使用相同的函数名但具有不同的参数列表或参数类型，来定义多个功能类似但参数不同的函数。
- 重载函数可以根据传入的参数类型或参数个数来决定使用哪个函数，实现了函数名的多态性。
- 重载函数的返回类型可以相同也可以不同，但仅根据返回类型是无法区分重载函数的。

函数重写（Overriding）：

- 重写是指在派生类中重新定义基类的函数，以改变或扩展基类函数的行为。
- 重写函数在基类和派生类中具有相同的函数名、参数列表和返回类型。

### 空类默认产生的类成员函数

```cpp
class Empty
{
public:
      Empty();                  //   缺省构造函数
      Empty(const Empty&);    	//   拷贝构造函数
      ~Empty();                 //   析构函数
      Empty& perator=(const Empty&); 	//   赋值运算符
      Empty* operator&();               //   取值运算符
      const Empty* operator&() const;   //   取值运算符
};
```

### 子类构造函数和析构函数

**与父类构造函数和析构函数执行顺序**

在C++中，当子类的对象创建时，会依次调用父类的构造函数和子类的构造函数。当子类的对象销毁时，会依次调用子类的析构函数和父类的析构函数。基类构造函数->内嵌对象的构造函数->派生类构造函数->派生类析构函数->内嵌对象的析构函数->基类析构函数

**显式调用父类构造函数和析构函数**

当父类构造函数带参数时，子类的构造函数和析构函数可以显式调用父类的构造函数和析构函数，以确保父类的构造和析构逻辑被正确执行。
如果子类的构造函数没有显式调用父类的构造函数或析构函数，编译器会自动调用父类的默认构造或析构函数。
子类构造函数显式调用父类构造函数：初始化列表使用冒号（:）后跟父类构造函数的调用语法：父类名(参数列表)。
子类析构函数显式调用父类析构函数：在子类析构函数中，使用父类名::~父类名() 的语法来显式调用父类的析构函数。

```cpp
class Parent {
public:
    Parent(int value1, int value2) {
        cout << "Parent constructor called with values: " << value1 << ", " << value2 << endl;
    
    ~Parent() {
        cout << "Parent destructor called" << endl;
    }
};

class Child : public Parent {
public:
    Child(int value1, int value2) : Parent(value1, value2) {
        cout << "Child constructor called with values: " << value1 << ", " << value2 << endl;
    }
    
    ~Child() {
        cout << "Child destructor called" << endl;
        Parent::~Parent();  // 显式调用父类析构函数
    }
};

int main() {
    Child obj(10, 20);  // 创建子类对象，显式调用父类的构造函数，并传递参数
}
```

### 拷贝构造函数

拷贝构造函数（Copy Constructor）是一个特殊的构造函数，用于创建一个新对象，它的内容完全复制另一个同类对象的值。拷贝构造函数通常用于以下情况：

- 当一个对象以值传递的方式传递给函数时，会调用拷贝构造函数创建一个新对象，并将原始对象的值复制到新对象中。
- 当一个对象通过赋值操作符（`=`）赋值给另一个对象时，也会调用拷贝构造函数。

浅拷贝是指在拷贝对象时，只复制对象中的成员变量的值，而不复制成员变量所指向的资源。这意味着原对象和拷贝对象将共享相同的资源，当一个对象修改了共享资源时，另一个对象也会受到影响。

```cpp
// 浅拷贝
#include <iostream>

class Person {
private:
    std::string name;
    int age;

public:
    Person(const std::string& n, int a) : name(n), age(a) {}

    // 浅拷贝构造函数
    Person(const Person& other) : name(other.name), age(other.age) {}

    void display() const {
        std::cout << "Name: " << name << ", Age: " << age << std::endl;
    }
};

int main() {
    Person john("John", 25);

    // 使用浅拷贝构造函数创建新对象
    Person johnCopy(john);

    john.display();
    johnCopy.display();

    return 0;
}
```

深拷贝是指在拷贝对象时，不仅复制对象中的成员变量的值，还复制成员变量所指向的资源。这样，原对象和拷贝对象拥有各自独立的资源，彼此之间的操作互不影响。

```cpp
// 深拷贝
#include <iostream>

class Student {
private:
    int* age;

public:
    Student(int a) {
        age = new int;
        *age = a;
    }

    // 深拷贝构造函数
    Student(const Student& other) {
        age = new int;
        *age = *(other.age);
    }

    ~Student() {
        delete age;
    }

    void setAge(int a) {
        *age = a;
    }

    int getAge() const {
        return *age;
    }
};

int main() {
    Student original(20);
    Student deepCopy(original); // 调用深拷贝构造函数

    std::cout << "Original age: " << original.getAge() << std::endl;
    std::cout << "Deep copy age: " << deepCopy.getAge() << std::endl;

    return 0;
}
```

### 虚函数和纯虚函数

虚函数（Virtual Function）：

- 虚函数是在基类中声明为虚函数的成员函数。
- 虚函数通过使用关键字`virtual`进行声明，并在基类中定义。
- 子类可以重写（override）基类的虚函数，以实现多态性。
- 虚函数通过基类指针或引用调用时，根据实际对象的类型来确定调用的是基类的虚函数还是子类的重写函数。

纯虚函数（Pure Virtual Function）：

- 纯虚函数是在基类中声明为纯虚函数的虚函数。
- 纯虚函数通过在基类中使用`virtual`关键字声明，并赋值为0来定义。
- 带有纯虚函数的类称为抽象类，不能实例化对象。
- 子类必须实现（override）基类的纯虚函数，才能成为具体的类。
- 纯虚函数可以为基类提供一个接口，要求派生类必须实现相应的功能。

### 编译时多态和运行时多态

- 编译时多态也称为静态多态性，是通过函数重载和模板实现的一种机制。在编译时多态中，编译器根据函数参数的静态类型来确定调用哪个函数重载或模板实例化。这种多态性的决策发生在编译时，因此称为编译时多态。
- 运行时多态是通过继承和虚函数实现的一种机制。在运行时多态中，通过基类指针或引用调用虚函数，根据实际对象的类型来确定调用的是基类的虚函数还是子类的重写函数。

### 函数模板和类模板

函数模板可以根据不同的数据类型自动生成具体的函数实例。通过函数模板，可以编写能够适用于多种数据类型的函数，实现代码的重用和泛化。

```cpp
//函数模板
template <typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    swap(x, y);  // 实例化出 swap<int>(x, y)
    cout << "x: " << x << ", y: " << y << endl;

    double a = 3.14, b = 2.71;
    swap(a, b);  // 实例化出 swap<double>(a, b)
    cout << "a: " << a << ", b: " << b << endl;
}
```

类模板可以根据不同的数据类型自动生成具体的类实例。通过类模板，可以编写能够适用于多种数据类型的类，实现代码的重用和泛化。

```cpp
//类模板
template <class T>
class Pair {
private:
    T first;
    T second;

public:
    Pair(const T& f, const T& s) : first(f), second(s) {}

    T getFirst() const {
        return first;
    }

    T getSecond() const {
        return second;
    }
};

int main() {
    Pair<int> intPair(1, 2);
    Pair<double> doublePair(3.14, 2.71);

    cout << "Int Pair: " << intPair.getFirst() << ", " << intPair.getSecond() << endl;
    cout << "Double Pair: " << doublePair.getFirst() << ", " << doublePair.getSecond() << endl;

    return 0;
}
```

### 运算符重载

运算符重载（Operator Overloading）是C++中的一项特性，它允许对已有的运算符进行重新定义，以适应用户自定义类型的操作需求。通过运算符重载，可以让用户定义的类对象使用类似于内置类型的操作符进行运算。例如，可以定义类对象之间的加法、减法、乘法、除法等操作，以及比较运算符（如等于、大于、小于等），使得用户定义的类对象可以通过这些运算符进行运算和比较。

```cpp
#include <iostream>

class Vector {
private:
    int x;
    int y;

public:
    Vector(int a, int b) : x(a), y(b) {}

    //+运算符重载
    Vector operator+(const Vector& other) const {
        int newX = x + other.x;
        int newY = y + other.y;
        return Vector(newX, newY);
    }

    void display() const {
        std::cout << "(" << x << ", " << y << ")" << std::endl;
    }
};

int main() {
    Vector v1(1, 2);
    Vector v2(3, 4);

    Vector result = v1 + v2;
    result.display();

    return 0;
}
```



## STL标准库

STL（Standard Template Library）是C++标准库的一部分，提供了一系列的模板类和函数，用于实现常见的数据结构和算法。
STL标准库主要由以下几个组件组成：

1. 容器（Containers）：STL提供了多种容器类，包括动态数组（vector）、双向链表（list）、双向队列（deque）、集合（set）、映射（map）等。这些容器类提供了不同的数据结构，以适应不同的需求。
2. 迭代器（Iterators）：STL的迭代器是一种抽象的数据访问方式，类似于指针，用于遍历和操作容器中的元素。迭代器提供了统一的接口，使得算法可以独立于容器类型而操作数据。
3. 算法（Algorithms）：STL提供了大量的算法，如排序、查找、拷贝、变换等，可以直接应用于容器中的元素。这些算法是模板函数，可以通过迭代器对容器进行操作。
4. 仿函数（Function Objects）：仿函数（Functor）是一种类或结构体，可以像函数一样被调用。仿函数是一种重载了函数调用运算符 `operator()` 的对象，使得对象可以像函数一样被调用，实现了函数调用符号的重载。
5. 适配器（Adapters）：适配器（Adapter）是一种用于将现有组件（容器、迭代器或函数对象）转换或包装成另一种形式或接口的工具。例如栈（stack）、队列（queue）和优先队列（priority_queue）。
6. 分配器（allocator）：也称为空间配置器，负责空间的配置与管理。从实现的角度来看，配置器是一个实现了动态配置空间、空间管理、空间释放的模板类。

### 容器

序列式容器（Sequence Containers）：

- 向量（Vector）：动态数组，支持快速随机访问，插入和删除操作效率较低。
- 链表（List）：双向链表，支持快速插入和删除操作，但访问元素的效率较低。
- 双端队列（Deque）：两端可操作的队列，支持快速随机访问、插入和删除操作。

关联式容器（Associative Containers）：

- 集合（Set）：有序的唯一值集合，支持快速查找、插入和删除操作。
- 映射（Map）：键值对的集合，支持按键快速查找、插入和删除操作。
- 多重集合（Multiset）：有序的可重复值集合，支持快速查找、插入和删除操作。
- 多重映射（Multimap）：键值对的集合，允许重复的键，支持按键快速查找、插入和删除操作。



## C++ 设计模式

设计模式是一种被反复使用、经过验证的解决特定问题的设计思想或方法。它们是在软件开发中针对常见问题或情景的经验总结，可以提供一种通用的解决方案。设计模式的目标是提高软件的可维护性、可扩展性、可重用性和灵活性，并降低代码的重复性和耦合度。通过使用设计模式，开发人员可以遵循一些已经被广泛接受的设计原则和约定，从而更好地组织和管理代码。c++常用的设计模式包括单例模式、工厂模式、抽象工厂模式、适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式、观察者模式和命令模式等。

### 单例模式

单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。单例模式在需要确保只有一个对象实例存在，并且该实例需要被全局共享时非常有用。实现单例模式的步骤：

1. 将构造函数私有化 
2. 在类中定义一个静态的指向本类型的指针变量  
3. 定义一个返回值为类指针的静态成员函数

**懒汉式和饿汉式**

懒汉式（Lazy Initialization）：

- 在懒汉式中，实例在首次使用时才被创建。
- 懒汉式的优点是延迟加载，只在需要时创建实例，节省了内存和资源。
- 懒汉式的缺点是线程不安全，在多线程环境下可能会导致多个实例的创建。

饿汉式（Eager Initialization）：

- 在饿汉式中，实例在类加载时就被创建。
- 饿汉式的优点是简单、线程安全，不存在多线程环境下的竞争问题。
- 饿汉式的缺点是无法实现延迟加载，即使没有使用该实例，也会被创建和初始化。

```cpp
class Singleton {
public:
    static Singleton* getInstance()
    {
        if(nullptr == pInstance)
        { 
            pInstance = new Singleton(); 
        }
        return pInstance;	
    }
    
private:
    Singleton() { cout << "Singleton()" << endl; }
    
private:
    Static Singleton* pInstance;
};

//懒汉式
Singleton* Singleton::pInstance = nullptr;
//饿汉式
//Singleton* Singleton::pInstance = new Singleton();

int main(void)
{
    Singleton* p1 = Singleton::getInstance();
    Singleton* p2 = Singleton::getInstance();
    assert(p1 == p2);
    return 0;
}
```

### 工厂模式

工厂模式定义了一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。工厂模式有以下优点

1. 一个调用者想创建一个对象，只要知道其名称就可以了；
2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以；
3. 屏蔽产品的具体实现，调用者只关心产品的接口。

#### 简单工厂

简单工厂把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象。

```cpp
enum CarType
{
    bmw, audi
};

class SimpleFactory
{
public:
    Car* createCar(CarType ct)
    {
        switch(ct)
        {
            case bmw:
                return new BMW("X1");
                break;
            case audi:
                return new Audi("A6");
                break;
            default:
                cout << "参数不正确" << endl;
                break;
        }
    }
}

int main()
{
    SimpleFactory* factory = new SimpleFactory();
    Car* p1 = factory->createCar(bmw);
    Car* p2 = factory->createCar(audi);
    
    return 0;
}
```

#### 工厂方法

工厂方法是简单工厂的改进，改进之处是每款产品对应一个工厂，该工厂只生产这一种产品，也就是只创建这个产品类对象。一个派生类就代表着一个工厂，每个工厂都有具体要生产的产品。
Factory基类，提供了一个纯虚函数（创建产品），派生类（具体产品的工厂）负责创建对应的产品，

```cpp
//工厂方法：
class Factory
{
public:
	virtual Car* createCar(string name) = 0;
};
//宝马工厂
class BMWFactory : public Factory
{
public:
	Car* createCar(string name) 
	{
		return new BMW(name);
	}
};
//奥迪工厂
class AudiFactory : public Factory
{
public:
	Car* createCar(string name)
	{
		return new Audi(name);
	}
};
 
void main()
{
	Factory* bmwfty = new BMWFactory();
	Factory* audifty = new AudiFactory();
 
	Car* p1 = bmwfty->createCar("X6");
	Car* p2 = audifty->createCar("A6");
 
	p1->show();
	p2->show();
}
```

#### 抽象工厂

抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，能够创建多个产品族的产品对象。抽象工厂模式实现步骤：

1. 提供一个抽象工厂类：声明一组创建一族产品的工厂方法
2. 提供一个具体工厂类：实现了在抽象工厂创建产品的工厂方法
3. 提供一个抽象产品类：抽象产品中声明了产品具有的业务方法
4. 提供一个具体产品类：实现抽象产品接口中声明的业务方法

```cpp
//系列产品1：
class Car 
{
public:
	Car(string name):_name(name)
	{}
	virtual void show()
	{}

protected:
	std::string _name;
};
 
class BMW:public Car
{
public:
	BMW(string name):Car(name)
	{}
	void show() {
		cout << "这是一辆宝马" << endl;
	}
};
 
class Audi :public Car
{
public:
	Audi(string name) :Car(name)
	{}
	void show() {
		cout << "这是一辆奥迪" << endl;
	}
};

//系列产品 2：
class Light
{
public:
	virtual void show()
	{
	}
};
class BmwLight :public Light
{
public:
	void show()
	{
		cout << "BMW 的 Light" << endl;
	}
};
class AudiLight :public Light
{
public:
	void show()
	{
		cout << "Audi 的 Light" << endl;
	}
};

//工厂方法 ==>> 抽象工厂（对一组关联关系的产品簇提供产品对象的统一创建）
class AbstractFactory
{
public:
	virtual Car* createCar(string name) = 0;		//工厂方法  创建汽车
	virtual Light* createLight() = 0;			    //工厂方法  创建汽车关联的产品，车灯
};
//宝马工厂
class BMWFactory : public AbstractFactory
{
public:
	Car* createCar(string name) 
	{
		return new BMW(name);
	}
	Light* createLight()
	{
		return new BmwLight();
	}
};
//奥迪工厂
class AudiFactory : public AbstractFactory
{
public:
	Car* createCar(string name)
	{
		return new Audi(name);
	}
	Light* createLight()
	{
		return new AudiLight();
	}
};

void main()
{
	AbstractFactory* bmwfty = new BMWFactory();
	AbstractFactory* audifty = new AudiFactory();
 
	Car* p1 = bmwfty->createCar("X6");
	Car* p2 = audifty->createCar("A6");
	p1->show();
	p2->show();
 
	Light* l1 = bmwfty->createLight();
	Light* l2 = audifty->createLight();
	l1->show();
	l2->show();
}
```

### 观察者模式

观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。以下是观察者模式结构：

1. 发布者 （Publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。
2. 当新事件发生时， 发布者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。
3. 订阅者 （Subscriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 update更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。

4. 具体订阅者 （Concrete Subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。

5. 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。

6. 客户端 （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。

```cpp
#include <iostream>
#include <list>
#include <string>
// 抽象主题类：定义了添加、删除和通知观察者的接口
class Subject {
public:
    virtual ~Subject() {}
    virtual void Attach(Observer* observer) = 0;
    virtual void Detach(Observer* observer) = 0;
    virtual void Notify() = 0;
};
// 抽象观察者类：定义了更新的接口
class Observer {
public:
    virtual ~Observer() {}
    virtual void Update(Subject* subject) = 0;
};
// 具体主题类：维护观察者列表，实现添加、删除和通知观察者的接口
class ConcreteSubject : public Subject {
public:
    virtual ~ConcreteSubject() {}
    virtual void Attach(Observer* observer) override {
        observers_.push_back(observer);
    }
    virtual void Detach(Observer* observer) override {
        observers_.remove(observer);
    }
    virtual void Notify() override {
        for (auto observer : observers_) {
            observer->Update(this);
        }
    }
    void SetState(const std::string& state) {
        state_ = state;
    }
    const std::string& GetState() const {
        return state_;
    }
private:
    std::list<Observer*> observers_;
    std::string state_;
};
// 具体观察者类：实现更新的接口
class ConcreteObserver : public Observer {
public:
    ConcreteObserver(const std::string& name) : name_(name) {}
    virtual ~ConcreteObserver() {}
    virtual void Update(Subject* subject) override {
        ConcreteSubject* concrete_subject = dynamic_cast<ConcreteSubject*>(subject);
        if (concrete_subject) {
            std::cout << name_ << " received the update: " << concrete_subject->GetState() << std::endl;
        }
    }
private:
    std::string name_;
};
int main() {
    // 创建具体主题对象
    ConcreteSubject subject;
    // 创建具体观察者对象
    ConcreteObserver observer1("Observer 1");
    ConcreteObserver observer2("Observer 2");
    ConcreteObserver observer3("Observer 3");
    // 添加观察者
    subject.Attach(&observer1);
    subject.Attach(&observer2);
    subject.Attach(&observer3);
    // 修改状态并通知观察者
    subject.SetState("State 1");
    subject.Notify();
    // 移除观察者
    subject.Detach(&observer2);
    // 修改状态并通知观察者
    subject.SetState("State 2");
    subject.Notify();
    return 0;
}
```



# C++ QT

## 元对象

Qt元对象系统（meta-object）提供了用于内部对象通讯的信号与槽（signals & slots）机制，运行时类型信息，以及动态属性系统；

1. QObject类为所有对象提供了一个基类，只要继承此类，创建出的对象便可以使用元对象系统；
2. 在声明类时，将Q_OBJECT宏放置于类的私有区域就可以在类中使能元对象特性，诸如动态属性，信号，以及槽。一般实际使用中，我们总是把Q_OBJECT宏放置在类声明时的开头位置，除此之外我们的类还需要继承QObject类;
3. 元对象编译器（Meta-Object Compiler，缩写moc），为每个QObject的子类提供必要的代码去实现元对象特性;

## 信号与槽

Qt的信号槽机制是一种用于实现对象间通信的机制。它允许一个对象（信号发出者）发出一个特定的信号，而另一个对象（槽函数接收者）可以接收这个信号并作出相应的反应。在Qt中，信号槽的实现依赖于元对象系统（Meta-Object System）的支持。这个系统通过在编译时为每个具有信号槽需求的类生成额外的元对象信息（MOC文件），实现了信号槽的动态连接。具体工作流程如下：

1. 定义信号：在类的声明中使用signals关键字声明一个信号，信号是一种特殊的成员函数，没有具体的实现。
2. 定义槽函数：在类的声明中声明一个槽函数，槽函数的定义和普通的成员函数一样。
3. 连接信号和槽：使用QObject::connect函数将信号和槽函数连接起来，这样当信号被发出时，槽函数会被调用。
4. 发出信号：通过使用emit关键字在信号发出者对象中发出一个信号。
5. 槽函数响应：当信号被发出时，如果与之连接的槽函数已经被执行，那么槽函数会被调用并执行相应的操作。

需要注意的是，信号和槽函数的参数类型和个数必须匹配（信号的参数个数可以比槽多），否则在连接时会产生编译错误。此外，信号和槽函数可以是任何访问权限（public、protected、private）的成员函数，但是在连接时只有具有公共访问权限（public）的信号和槽函数才能被连接成功。

**信号与槽的多种用法**

- 一个信号可以和多个槽相连	这时槽的执行顺序和在不在同一个线程上有关，同一线程，槽的执行顺序和声明顺序有关，跨线程时，执行顺序是不确定的。
- 多个信号可以连接到一个槽	只要任意一个信号发出，这个槽就会被调用。
- 一个信号可以连接到另外的一个信号	当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。
- 槽可以被取消链接	这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。想主动取消连接就用disconnect()函数中添加任何实现。

**信号槽第五个参数**
在Qt的信号槽机制中，第五个参数是Qt::ConnectionType，用于指定信号槽的连接类型。Qt提供了几种不同的连接类型，常用的有以下几种：

- AutoConnection（默认类型）：当发送信号和接收信号的对象处于同一线程时，使用直接连接（DirectConnection）。当发送信号和接收信号的对象处于不同线程时，使用队列连接（QueuedConnection）。

- DirectConnection：发送信号时，立即调用绑定的槽函数，无论信号和槽函数所属的对象是否在同一线程。这种连接类型适用于信号发送者和接收者在同一线程，且希望及时处理信号。
- QueuedConnection：发送信号时，将信号放入接收对象所在线程的事件队列中，等待事件循环处理。这种连接类型适用于信号发送者和接收者在不同线程，且希望异步处理信号。
- BlockingQueuedConnection：发送信号时，阻塞发送者线程，等待接收者线程处理完信号槽函数后继续执行。这种连接类型适用于信号发送者和接收者在不同线程，但需要同步处理信号。
- UniqueConnection：在连接信号槽之前，检查是否已经存在相同的连接，如果存在则不再连接。这种连接类型适用于希望确保只有一个连接被建立的场景。

## 事件机制的过滤

1. 重载特定事件处理函数    最常见的事件处理办法就是重载像mousePressEvent(), keyPressEvent(), paintEvent() 这样的特定事件处理函数.
2. 重载event()函数    通过重载event()函数，我们可以在事件被特定的事件处理函数处理之前(像keyPressEvent())处理它. 
3. 在Qt对象上安装事件过滤器
4. 给QAppliction对象安装事件过滤器
5. 继承QApplication类,并重载notify()函数.

